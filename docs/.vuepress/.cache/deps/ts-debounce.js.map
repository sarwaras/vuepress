{
  "version": 3,
  "sources": ["../../../../node_modules/ts-debounce/src/index.ts"],
  "sourcesContent": ["export type Options<Result> = {\n  isImmediate?: boolean;\n  maxWait?: number;\n  callback?: (data: Result) => void;\n};\n\nexport interface DebouncedFunction<\n  Args extends any[],\n  F extends (...args: Args) => any\n> {\n  (this: ThisParameterType<F>, ...args: Args): Promise<ReturnType<F>>;\n  cancel: (reason?: any) => void;\n}\n\ninterface DebouncedPromise<FunctionReturn> {\n  resolve: (result: FunctionReturn) => void;\n  reject: (reason?: any) => void;\n}\n\nexport function debounce<Args extends any[], F extends (...args: Args) => any>(\n  func: F,\n  waitMilliseconds = 50,\n  options: Options<ReturnType<F>> = {}\n): {\n  (this: ThisParameterType<F>, ...args: Parameters<F> & Args): Promise<\n    ReturnType<F>\n  >;\n  cancel: (reason?: any) => void;\n} {\n  let timeoutId: ReturnType<typeof setTimeout> | undefined;\n  const isImmediate = options.isImmediate ?? false;\n  const callback = options.callback ?? false;\n  const maxWait = options.maxWait;\n  let lastInvokeTime = Date.now();\n\n  let promises: DebouncedPromise<ReturnType<F>>[] = [];\n\n  function nextInvokeTimeout() {\n    if (maxWait !== undefined) {\n      const timeSinceLastInvocation = Date.now() - lastInvokeTime;\n\n      if (timeSinceLastInvocation + waitMilliseconds >= maxWait) {\n        return maxWait - timeSinceLastInvocation;\n      }\n    }\n\n    return waitMilliseconds;\n  }\n\n  const debouncedFunction = function (\n    this: ThisParameterType<F>,\n    ...args: Parameters<F>\n  ) {\n    const context = this;\n    return new Promise<ReturnType<F>>((resolve, reject) => {\n      const invokeFunction = function () {\n        timeoutId = undefined;\n        lastInvokeTime = Date.now();\n        if (!isImmediate) {\n          const result = func.apply(context, args);\n          callback && callback(result);\n          promises.forEach(({ resolve }) => resolve(result));\n          promises = [];\n        }\n      };\n\n      const shouldCallNow = isImmediate && timeoutId === undefined;\n\n      if (timeoutId !== undefined) {\n        clearTimeout(timeoutId);\n      }\n\n      timeoutId = setTimeout(invokeFunction, nextInvokeTimeout());\n\n      if (shouldCallNow) {\n        const result = func.apply(context, args);\n        callback && callback(result);\n        return resolve(result);\n      }\n      promises.push({ resolve, reject });\n    });\n  };\n\n  debouncedFunction.cancel = function (reason?: any) {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n    }\n    promises.forEach(({ reject }) => reject(reason));\n    promises = [];\n  };\n\n  return debouncedFunction;\n}\n"],
  "mappings": ";;;WAoBE,IACA,GACA,GAAA;AAAA,MAAA,GAAA,GAOI;AAAA,EARJ,MAQI,UARJ,KAAmB,KAAA,AACnB,MADmB,UACnB,KAAkC,CAAA;AAQlC,MAAM,IAAA,AAAA,KAAc,EAAQ,gBAAtB,QAAsB,GACtB,IAAA,AAAA,KAAW,EAAQ,aAAnB,QAAmB,GACnB,IAAU,EAAQ,SACpB,IAAiB,KAAK,IAAA,GAEtB,IAA8C,CAAA;AAElD,eAAS;AACP,QAAA,AAAI,MAAJ,QAA2B;AACzB,UAAM,KAA0B,KAAK,IAAA,IAAQ;AAE7C,UAAI,KAA0B,KAAoB;AAChD,eAAO,IAAU;IAAA;AAIrB,WAAO;EAAA;AAGT,MAAM,IAAoB,WAAA;AAAA,QAErB,KAAA,CAAA,EAAA,MAAA,KAAA,SAAA,GAEG,KAAU;AAChB,WAAA,IAAW,QAAuB,SAAC,IAAS,IAAA;AAC1C,UAWM,KAAgB,KAAA,AAAe,MAAf;AAQtB,UAAA,AANI,MAMJ,UALE,aAAa,CAAA,GAGf,IAAY,WAjBW,WAAA;AAGrB,YAFA,IAAA,QACA,IAAiB,KAAK,IAAA,GAAA,CACjB,GAAa;AAChB,cAAM,KAAS,GAAK,MAAM,IAAS,EAAA;AACnC,eAAY,EAAS,EAAA,GACrB,EAAS,QAAQ,SAAA,IAAA;AAAA,mBAAiB,IAAA,GAAd,SAAsB,EAAA;UAAA,CAAA,GAC1C,IAAW,CAAA;QAAA;MAAA,GAUwB,EAAA,CAAA,GAEnC,IAAe;AACjB,YAAM,KAAS,GAAK,MAAM,IAAS,EAAA;AAEnC,eADA,KAAY,EAAS,EAAA,GACd,GAAQ,EAAA;MAAA;AAEjB,QAAS,KAAK,EAAE,SAAA,IAAS,QAAA,GAAA,CAAA;IAAA,CAAA;EAAA;AAY7B,SARA,EAAkB,SAAS,SAAU,IAAA;AAAA,IAC/B,MAD+B,UAEjC,aAAa,CAAA,GAEf,EAAS,QAAQ,SAAA,IAAA;AAAA,aAAgB,IAAA,GAAb,QAAoB,EAAA;IAAA,CAAA,GACxC,IAAW,CAAA;EAAA,GAGN;AAAA;",
  "names": []
}
